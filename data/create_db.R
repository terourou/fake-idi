# message("Connecting to SQL Server ...\n")

# library(odbc)
# con <- dbConnect(
#     odbc(),
#     driver = "ODBC Driver 18 for SQL Server",
#     server = paste(Sys.getenv("DB_HOST"), Sys.getenv("DB_PORT"), sep = ","),
#     database = Sys.getenv("DB_DATABASE"),
#     uid = Sys.getenv("DB_UID"),
#     pwd = Sys.getenv("DB_PWD"),
#     TrustServerCertificate = "yes"
# )

files <- list.files("idi-data/Final datasets")
variables <- read.csv('variable-lists/varlist.csv')

schema_table <- lapply(files,
    \(file) {
        x <- strsplit(tools::file_path_sans_ext(file),
            "]_[", fixed = TRUE)[[1]]

        data.frame(
            schema = paste0(x[1], "]"),
            table = paste0("[", x[2])
        )
    }
)
schema_table <- do.call(rbind, schema_table)

schemas <- tapply(
    seq_len(nrow(schema_table)),
    schema_table$schema,
    \(i) {
        x <- schema_table[i, ]
        list(
            schema = x$schema[1],
            tables = x$table
        )
    }
) |> stats::setNames(NULL) |>
    lapply(\(x) {
        schema <- x$schema

        # sql <- c(
        #     sprintf("DROP SCHEMA IF EXISTS %s;\nGO", schema),
        #     sprintf("CREATE SCHEMA %s;\nGO", schema)
        # ) |> paste(collapse = "\n\n")

        tables <- lapply(x$tables,
            function(table) {
                # find the variable list for this table
                table_file <- paste0("idi-data/Final datasets/",
                    schema, "_", table, ".csv")
                table_data <- read.csv(table_file)
                schema_raw <- gsub("\\[|\\]", "", schema)
                table_raw <- gsub("\\[|\\]", "", table)
                table_vars <- variables[variables$TABLE_SCHEMA == schema_raw &
                                        variables$TABLE_NAME == table_raw,
                                        c("COLUMN_NAME", "DATA_TYPE")] |>
                    stats::setNames(c("name", "type"))

                table_data <- table_data[,
                    names(table_data) %in% table_vars$name]
                table_vars <- table_vars[table_vars$name %in% names(table_data), ]

                table_vars[, "type"] <- apply(table_vars, 1,
                    \(v) {
                        v <- as.character(v)
                        if (!v[2] %in% c("char", "varchar")) return(v[2])
                        # for char and varchar, find the max length
                        max_len <- suppressWarnings(
                            max(nchar(table_data[[v[1]]]),
                                na.rm = TRUE)
                        )
                        if (!is.finite(max_len)) max_len <- 1L
                        sprintf("%s(%i)", v[2], max_len)
                    }
                )
                table_vars[, "name"] <- paste0("[", table_vars[, "name"], "]")

                return(list(
                    table = table,
                    variables = table_vars,
                    data = table_data
                ))
            }
        )

        list(
            schema = schema,
            tables = tables
        )

    }
)

# generate SQL to create tables (in batches of MAX 1000 rows)
out_file <- "create_db.sql"
file.remove(out_file)
cat("-- This file was generated by create_db.R\n\n",
    file = out_file, append = TRUE)

cat("USE IDI;\nGO\n\n\n", file = out_file, append = TRUE)

lapply(schemas,
    \(schema) {
        cat("-- ", schema$schema, "\n", file = out_file, append = TRUE)
        cat("PRINT '>>>> ", schema$schema, "';\nGO\n\n", file = out_file, append = TRUE)
        lapply(schema$tables,
            \(table) {
                # delete table first, if it exists
                cat(sprintf("DROP TABLE IF EXISTS %s.%s;\nGO\n",
                    schema$schema, table$table),
                    file = out_file, append = TRUE)
            }
        )
        cat(sprintf("DROP SCHEMA IF EXISTS %s;\nGO\n", schema$schema),
            file = out_file, append = TRUE)
        cat(sprintf("CREATE SCHEMA %s;\nGO\n", schema$schema),
            file = out_file, append = TRUE)

        lapply(schema$tables,
            \(table) {
                cat("PRINT '>>>> ", schema$schema, ".", table$table, "';\nGO\n",
                    file = out_file, append = TRUE)
                cat(sprintf("CREATE TABLE %s.%s (\n",
                    schema$schema, table$table),
                    file = out_file, append = TRUE)
                cat(paste0("    ", table$variables$name, " ",
                    table$variables$type, collapse = ",\n"),
                    file = out_file, append = TRUE)
                cat(");\nGO\n\n", file = out_file, append = TRUE)

                # wrap non-numeric values in quotes
                table$data <- do.call(data.frame,
                    lapply(table$data, \(x) {
                        if (!is.numeric(x)) x <- sprintf("'%s'", x)
                        # replace 'NA' with '' (empty string)
                        x <- ifelse(x == "'NA'", "''", x)
                        # replace NA numbers with NULL
                        x <- ifelse(is.na(x), "NULL", x)
                        x
                    })
                )

                # insert data in batches of 1000
                n <- nrow(table$data)
                for (i in seq(1, n, 1000)) {
                    cat(sprintf("INSERT INTO %s.%s\n",
                        schema$schema, table$table),
                        file = out_file, append = TRUE)
                    cat(sprintf("    (%s)\n",
                        paste0(colnames(table$data), collapse = ", ")),
                        file = out_file, append = TRUE)
                    cat("VALUES\n", file = out_file, append = TRUE)
                    cat(paste0("    (",
                        apply(table$data[i:min(i + 999, n), ], 1,
                            \(x) {
                                sprintf("%s",
                                    paste0(x, collapse = ", "))
                            }
                        ),
                        ")", collapse = ",\n"),
                        file = out_file, append = TRUE)
                    cat(";\nGO\n\n", file = out_file, append = TRUE)
                }
            }
        )
    }
)










# |> paste(collapse = "\n\n\n\n") |> cat(file = "create_db.sql")




# lapply(schemas,
#     \(schema) {
#         dbGetQuery(con, sprintf("DROP SCHEMA IF EXISTS %s", schema$schema))
#         dbGetQuery(con,
#             sprintf("CREATE SCHEMA %s", schema$schema)
#         )
#     }
# )

# dbGetQuery(con,
#     paste(sep = "\n",
#         sprintf("CREATE SCHEMA %s", "[data]"),
#         sprintf("CREATE TABLE ")

# )

# lapply(schemas,
#     \(schema) {
#         sapply(schema$tables,
#             \(table) {
#                 try(dbRemoveTable(con, paste(schema$schema, table, sep = "."),
#                     fail_if_missing = FALSE))
#             }
#         )
#     })

#         dbSendQuery(con,
#             paste0("DROP SCHEMA IF EXISTS ", schema$schema)
#         )

#         dbSendQuery(con,
#             paste0("CREATE SCHEMA ", schema$schema)
#         )

#         sapply(schema$tables,
#             \(table) {
#                 f <- paste0("/data/idi-data/Final datasets/",
#                     schema$schema, "_", table, ".csv")
#                 d <- read.csv(f)
#                 dbWriteTable(con, paste(schema$schema, table, sep = "."), d)
#                 # dbSendQuery(con,
#                 #     paste0("CREATE TABLE ", schema$schema, ".", table, " (",
#                 #         paste0(colnames(d), " VARCHAR(255)", collapse = ", "),
#                 #         collapse = ", ",
#                 #         sep = ""
#                 #     ), ")"
#                 # )
#             }
#         )
#     }
# )
